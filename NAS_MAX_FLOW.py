# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lx1Oc6H8lfE3IrvjqU9xADH9F07p5NG_
"""

import csv
import pandas as pd
import numpy as np

data = pd.read_csv('/content/flights.txt',  delim_whitespace=True, header=None )

def convert_time(time):
	# 6 am is 0 and 5 am is 23
	if time == 24:
		time == 0
	return time-6 if (time-6) >= 0 else time+18

def cvrt(apt, time):
	if apt == "LAX":
		index = 0
	elif apt == "SFO":
		index = 1 + time
	elif apt == "PHX":
		index = 25 + time
	elif apt == "SEA":
		index = 49 + time
	elif apt == "DEN":
		index = 73 + time
	elif apt == "ATL":
		index = 97 + time
	elif apt == "ORD":
		index = 121 + time
	elif apt == "BOS":
		index = 145 + time
	elif apt == "IAD":
		index = 169 + time
	elif apt == "JFK":
		index = 193
	else:
		index = -1
	return index


def mat(aMAT):
	for row in aMAT:
		print('  '.join([str(cell) for cell in row]))


def Breadth_First_Search(graph, s, t, parent):
	visited = [False] * len(graph)
	queue = [s]
	visited[s] = True
 
	while queue:
		u = queue.pop(0)
		for ind in range(len(graph[u])):
			if not visited[ind] and graph[u][ind] > 0:
				queue.append(ind)
				visited[ind] = True
				parent[ind] = u
 
	return visited[t]


def FF(graph, source, destination):
    parent = [-1] * (len(graph))
    max_flow = 0
    while Breadth_First_Search(graph, source, destination, parent):
        path_flow = float('inf')
        s = destination

        while s != source:
            path_flow = min(path_flow, graph[parent[s]][s])
            s = parent[s]

        max_flow += path_flow
        v = destination

        while v != source:
            u = parent[v]
            graph[u][v] -= path_flow
            graph[v][u] += path_flow
            v = parent[v]
    return max_flow


apt = ["SFO", "PHX", "SEA", "DEN", "ATL", "ORD", "BOS","IAD"]
flights = ["AA", "DL", "UA"]

size = len(apt)*24+2
adj_mat = [[0 for x in range(size)] for y in range(size)] 

direct_flights_cap = 0
max_cap = float('inf')

for tup in data.iterrows():
    row = tup[1]
    source = row[0]
    destination = row[1]
    dep = int(row[2])
    arr = int(row[3])
    capacity = int(row[4])

    dep = convert_time(dep)
    arr = convert_time(arr)

    if not (dep > arr):
        if (source in apt+["LAX","JFK"]) and (destination in apt+["LAX","JFK"]):
            x = int(cvrt(source, dep))
            y = int(cvrt(destination, arr))
            if (x==0) and (y == 193):
                direct_flights_cap += capacity
            else:
                adj_mat[x][y] = capacity

for i in range(1,194):
    for j in range(1, 194):
        if i < j:
            if ((24>=i>=1 and 24>=j>=1) and (i<=24 and j<=24)):
                adj_mat[i][j] = max_cap
            elif ((i>=25 and j>=25) and (i<=48 and j<=48)):
                adj_mat[i][j] = max_cap
            elif ((i>=49 and j>=49) and (i<=72 and j<=72)):
                adj_mat[i][j] = max_cap
            elif ((i>=73 and j>=73) and (i<=96 and j<=96)):
                adj_mat[i][j] = max_cap
            elif ((i>=97 and j>=97) and (i<=120 and j<=120)):
                adj_mat[i][j] = max_cap
            elif ((i>=121 and j>=121) and (i<=144 and j<=144)):
                adj_mat[i][j] = max_cap
            elif ((i>=145 and j>=145) and (i<=168 and j<=168)):
                adj_mat[i][j] = max_cap
            elif ((i>=169 and j>=169)):
                adj_mat[i][j] = max_cap



print(FF(adj_mat, 0, 193))